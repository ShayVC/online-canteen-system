{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\shaym\\\\Downloads\\\\newonlinecanteen\\\\newonlinecanteen\\\\frontend\\\\src\\\\contexts\\\\OrderContext.js\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState, useEffect, useCallback } from 'react';\nimport axios from 'axios';\nimport { toast } from 'react-toastify';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const OrderContext = /*#__PURE__*/createContext();\n\n// Sample data for when the backend is not available\nconst SAMPLE_ORDERS = [{\n  userID: 1,\n  customerName: \"John Doe\",\n  orderDate: \"2025-05-05T08:30:00\",\n  totalPrice: 15.98,\n  status: \"COMPLETED\",\n  items: \"Hamburger (x1), French Fries (x1), Soft Drink (x1)\"\n}, {\n  userID: 2,\n  customerName: \"Jane Smith\",\n  orderDate: \"2025-05-05T09:15:00\",\n  totalPrice: 12.49,\n  status: \"PREPARING\",\n  items: \"Chicken Sandwich (x1), Onion Rings (x1), Iced Tea (x1)\"\n}, {\n  userID: 3,\n  customerName: \"Michael Johnson\",\n  orderDate: \"2025-05-05T10:00:00\",\n  totalPrice: 24.97,\n  status: \"READY\",\n  items: \"Pizza Slice (x2), Caesar Salad (x1), Coffee (x2)\"\n}];\nexport const OrderProvider = ({\n  children\n}) => {\n  _s();\n  const [orders, setOrders] = useState(SAMPLE_ORDERS);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [backendAvailable, setBackendAvailable] = useState(false);\n\n  // Fetch all orders\n  const fetchOrders = useCallback(async () => {\n    setLoading(true);\n    try {\n      const response = await axios.get('/api/orders');\n      setOrders(response.data);\n      setError(null);\n      setBackendAvailable(true);\n    } catch (err) {\n      var _err$response;\n      // If backend is not available, use sample data\n      if (err.message.includes('Network Error') || ((_err$response = err.response) === null || _err$response === void 0 ? void 0 : _err$response.status) === 500) {\n        setOrders(SAMPLE_ORDERS);\n        setError('Backend server is not available. Using sample data.');\n        toast.warning('Backend server is not available. Using sample data for demonstration purposes.');\n        setBackendAvailable(false);\n      } else {\n        setError('Failed to fetch orders');\n        toast.error('Failed to fetch orders');\n      }\n      console.error('Error fetching orders:', err);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Fetch a single order by ID\n  const fetchOrderById = useCallback(async id => {\n    setLoading(true);\n    try {\n      if (!backendAvailable) {\n        // Use sample data if backend is not available\n        const order = SAMPLE_ORDERS.find(order => order.userID === parseInt(id));\n        if (order) {\n          setError(null);\n          return order;\n        } else {\n          // Create a fallback order if ID wasn't found in sample data\n          const fallbackOrder = {\n            userID: parseInt(id),\n            customerName: \"Guest Customer\",\n            orderDate: new Date().toISOString(),\n            totalPrice: 0,\n            status: \"PREPARING\",\n            items: \"Unknown item\"\n          };\n          toast.info('Order not found in sample data. Creating placeholder order.');\n          return fallbackOrder;\n        }\n      }\n      const response = await axios.get(`/api/orders/${id}`);\n      setError(null);\n      return response.data;\n    } catch (err) {\n      var _err$response2;\n      // If backend is not available but we haven't detected it yet\n      if (err.message.includes('Network Error') || ((_err$response2 = err.response) === null || _err$response2 === void 0 ? void 0 : _err$response2.status) === 500) {\n        setBackendAvailable(false);\n        // Try to find in sample data\n        const order = SAMPLE_ORDERS.find(order => order.userID === parseInt(id));\n        if (order) {\n          toast.warning('Backend server is not available. Using sample data for demonstration purposes.');\n          return order;\n        } else {\n          // Create a fallback order if ID wasn't found\n          const fallbackOrder = {\n            userID: parseInt(id),\n            customerName: \"Guest Customer\",\n            orderDate: new Date().toISOString(),\n            totalPrice: 0,\n            status: \"PREPARING\",\n            items: \"Unknown item\"\n          };\n          toast.info('Order not found. Creating placeholder order for demonstration.');\n          return fallbackOrder;\n        }\n      }\n      setError('Failed to fetch order details');\n      toast.error('Failed to fetch order details');\n      console.error('Error fetching order:', err);\n\n      // Return a fallback order even when error occurs\n      const fallbackOrder = {\n        userID: parseInt(id),\n        customerName: \"Guest Customer\",\n        orderDate: new Date().toISOString(),\n        totalPrice: 0,\n        status: \"PREPARING\",\n        items: \"Unknown item\"\n      };\n      return fallbackOrder;\n    } finally {\n      setLoading(false);\n    }\n  }, [backendAvailable]);\n\n  // Create a new order\n  const createOrder = useCallback(async orderData => {\n    setLoading(true);\n    try {\n      if (!backendAvailable) {\n        // Create a mock order if backend is not available\n        const newOrder = {\n          ...orderData,\n          userID: SAMPLE_ORDERS.length + 1,\n          orderDate: new Date().toISOString(),\n          status: 'PREPARING'\n        };\n        setOrders(prevOrders => [...prevOrders, newOrder]);\n        toast.success('Order created successfully! (Using sample data)');\n        setError(null);\n        return newOrder;\n      }\n      const response = await axios.post('/api/orders', orderData);\n      setOrders(prevOrders => [...prevOrders, response.data]);\n      toast.success('Order created successfully!');\n      setError(null);\n      return response.data;\n    } catch (err) {\n      var _err$response3;\n      // If backend is not available but we haven't detected it yet\n      if (err.message.includes('Network Error') || ((_err$response3 = err.response) === null || _err$response3 === void 0 ? void 0 : _err$response3.status) === 500) {\n        setBackendAvailable(false);\n        // Create a mock order\n        const newOrder = {\n          ...orderData,\n          userID: SAMPLE_ORDERS.length + 1,\n          orderDate: new Date().toISOString(),\n          status: 'PREPARING'\n        };\n        setOrders(prevOrders => [...prevOrders, newOrder]);\n        toast.warning('Backend server is not available. Created order with sample data.');\n        return newOrder;\n      }\n      setError('Failed to create order');\n      toast.error('Failed to create order');\n      console.error('Error creating order:', err);\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [backendAvailable]);\n\n  // Update an order\n  const updateOrder = useCallback(async (id, orderData) => {\n    setLoading(true);\n    try {\n      if (!backendAvailable) {\n        // Update order in sample data if backend is not available\n        const updatedOrder = {\n          ...orderData,\n          userID: parseInt(id)\n        };\n        setOrders(prevOrders => prevOrders.map(order => order.userID === parseInt(id) ? updatedOrder : order));\n        toast.success('Order updated successfully! (Using sample data)');\n        setError(null);\n        return updatedOrder;\n      }\n      const response = await axios.put(`/api/orders/${id}`, orderData);\n      setOrders(prevOrders => prevOrders.map(order => order.userID === parseInt(id) ? response.data : order));\n      toast.success('Order updated successfully!');\n      setError(null);\n      return response.data;\n    } catch (err) {\n      var _err$response4;\n      // If backend is not available but we haven't detected it yet\n      if (err.message.includes('Network Error') || ((_err$response4 = err.response) === null || _err$response4 === void 0 ? void 0 : _err$response4.status) === 500) {\n        setBackendAvailable(false);\n        // Update in sample data\n        const updatedOrder = {\n          ...orderData,\n          userID: parseInt(id)\n        };\n        setOrders(prevOrders => prevOrders.map(order => order.userID === parseInt(id) ? updatedOrder : order));\n        toast.warning('Backend server is not available. Updated order with sample data.');\n        return updatedOrder;\n      }\n      setError('Failed to update order');\n      toast.error('Failed to update order');\n      console.error('Error updating order:', err);\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [backendAvailable]);\n\n  // Update order status\n  const updateOrderStatus = useCallback(async (id, newStatus) => {\n    setLoading(true);\n    try {\n      if (!backendAvailable) {\n        // Update status in sample data if backend is not available\n        let updatedOrder = null;\n        setOrders(prevOrders => {\n          const newOrders = prevOrders.map(order => {\n            if (order.userID === parseInt(id)) {\n              updatedOrder = {\n                ...order,\n                status: newStatus\n              };\n              return updatedOrder;\n            }\n            return order;\n          });\n          return newOrders;\n        });\n        toast.success(`Order status updated to ${newStatus} (Using sample data)`);\n        setError(null);\n        return updatedOrder;\n      }\n      const response = await axios.patch(`/api/orders/${id}/status`, newStatus);\n      setOrders(prevOrders => prevOrders.map(order => order.userID === parseInt(id) ? response.data : order));\n      toast.success(`Order status updated to ${newStatus}`);\n      setError(null);\n      return response.data;\n    } catch (err) {\n      var _err$response5;\n      // If backend is not available but we haven't detected it yet\n      if (err.message.includes('Network Error') || ((_err$response5 = err.response) === null || _err$response5 === void 0 ? void 0 : _err$response5.status) === 500) {\n        setBackendAvailable(false);\n        // Update in sample data\n        let updatedOrder = null;\n        setOrders(prevOrders => {\n          const newOrders = prevOrders.map(order => {\n            if (order.userID === parseInt(id)) {\n              updatedOrder = {\n                ...order,\n                status: newStatus\n              };\n              return updatedOrder;\n            }\n            return order;\n          });\n          return newOrders;\n        });\n        toast.warning('Backend server is not available. Updated order status with sample data.');\n        return updatedOrder;\n      }\n      setError('Failed to update order status');\n      toast.error('Failed to update order status');\n      console.error('Error updating order status:', err);\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [backendAvailable]);\n\n  // Delete an order\n  const deleteOrder = useCallback(async id => {\n    setLoading(true);\n    try {\n      if (!backendAvailable) {\n        // Delete from sample data if backend is not available\n        setOrders(prevOrders => prevOrders.filter(order => order.userID !== parseInt(id)));\n        toast.success('Order deleted successfully! (Using sample data)');\n        setError(null);\n        return true;\n      }\n      await axios.delete(`/api/orders/${id}`);\n      setOrders(prevOrders => prevOrders.filter(order => order.userID !== parseInt(id)));\n      toast.success('Order deleted successfully!');\n      setError(null);\n      return true;\n    } catch (err) {\n      var _err$response6;\n      // If backend is not available but we haven't detected it yet\n      if (err.message.includes('Network Error') || ((_err$response6 = err.response) === null || _err$response6 === void 0 ? void 0 : _err$response6.status) === 500) {\n        setBackendAvailable(false);\n        // Delete from sample data\n        setOrders(prevOrders => prevOrders.filter(order => order.userID !== parseInt(id)));\n        toast.warning('Backend server is not available. Deleted order from sample data.');\n        return true;\n      }\n      setError('Failed to delete order');\n      toast.error('Failed to delete order');\n      console.error('Error deleting order:', err);\n      return false;\n    } finally {\n      setLoading(false);\n    }\n  }, [backendAvailable]);\n\n  // Load orders on initial mount\n  useEffect(() => {\n    fetchOrders();\n  }, [fetchOrders]);\n  const contextValue = {\n    orders,\n    loading,\n    error,\n    backendAvailable,\n    fetchOrders,\n    fetchOrderById,\n    createOrder,\n    updateOrder,\n    updateOrderStatus,\n    deleteOrder\n  };\n  return /*#__PURE__*/_jsxDEV(OrderContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 358,\n    columnNumber: 5\n  }, this);\n};\n_s(OrderProvider, \"+fas6Q4W+ORF9GaBnK4W/lCIz3g=\");\n_c = OrderProvider;\nvar _c;\n$RefreshReg$(_c, \"OrderProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useCallback","axios","toast","jsxDEV","_jsxDEV","OrderContext","SAMPLE_ORDERS","userID","customerName","orderDate","totalPrice","status","items","OrderProvider","children","_s","orders","setOrders","loading","setLoading","error","setError","backendAvailable","setBackendAvailable","fetchOrders","response","get","data","err","_err$response","message","includes","warning","console","fetchOrderById","id","order","find","parseInt","fallbackOrder","Date","toISOString","info","_err$response2","createOrder","orderData","newOrder","length","prevOrders","success","post","_err$response3","updateOrder","updatedOrder","map","put","_err$response4","updateOrderStatus","newStatus","newOrders","patch","_err$response5","deleteOrder","filter","delete","_err$response6","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/shaym/Downloads/newonlinecanteen/newonlinecanteen/frontend/src/contexts/OrderContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect, useCallback } from 'react';\nimport axios from 'axios';\nimport { toast } from 'react-toastify';\n\nexport const OrderContext = createContext();\n\n// Sample data for when the backend is not available\nconst SAMPLE_ORDERS = [\n  {\n    userID: 1,\n    customerName: \"John Doe\",\n    orderDate: \"2025-05-05T08:30:00\",\n    totalPrice: 15.98,\n    status: \"COMPLETED\",\n    items: \"Hamburger (x1), French Fries (x1), Soft Drink (x1)\"\n  },\n  {\n    userID: 2,\n    customerName: \"Jane Smith\",\n    orderDate: \"2025-05-05T09:15:00\",\n    totalPrice: 12.49,\n    status: \"PREPARING\",\n    items: \"Chicken Sandwich (x1), Onion Rings (x1), Iced Tea (x1)\"\n  },\n  {\n    userID: 3,\n    customerName: \"Michael Johnson\",\n    orderDate: \"2025-05-05T10:00:00\",\n    totalPrice: 24.97,\n    status: \"READY\",\n    items: \"Pizza Slice (x2), Caesar Salad (x1), Coffee (x2)\"\n  }\n];\n\nexport const OrderProvider = ({ children }) => {\n  const [orders, setOrders] = useState(SAMPLE_ORDERS);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [backendAvailable, setBackendAvailable] = useState(false);\n\n  // Fetch all orders\n  const fetchOrders = useCallback(async () => {\n    setLoading(true);\n    try {\n      const response = await axios.get('/api/orders');\n      setOrders(response.data);\n      setError(null);\n      setBackendAvailable(true);\n    } catch (err) {\n      // If backend is not available, use sample data\n      if (err.message.includes('Network Error') || err.response?.status === 500) {\n        setOrders(SAMPLE_ORDERS);\n        setError('Backend server is not available. Using sample data.');\n        toast.warning('Backend server is not available. Using sample data for demonstration purposes.');\n        setBackendAvailable(false);\n      } else {\n        setError('Failed to fetch orders');\n        toast.error('Failed to fetch orders');\n      }\n      console.error('Error fetching orders:', err);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Fetch a single order by ID\n  const fetchOrderById = useCallback(async (id) => {\n    setLoading(true);\n    try {\n      if (!backendAvailable) {\n        // Use sample data if backend is not available\n        const order = SAMPLE_ORDERS.find(order => order.userID === parseInt(id));\n        if (order) {\n          setError(null);\n          return order;\n        } else {\n          // Create a fallback order if ID wasn't found in sample data\n          const fallbackOrder = {\n            userID: parseInt(id),\n            customerName: \"Guest Customer\",\n            orderDate: new Date().toISOString(),\n            totalPrice: 0,\n            status: \"PREPARING\",\n            items: \"Unknown item\"\n          };\n          toast.info('Order not found in sample data. Creating placeholder order.');\n          return fallbackOrder;\n        }\n      }\n      \n      const response = await axios.get(`/api/orders/${id}`);\n      setError(null);\n      return response.data;\n    } catch (err) {\n      // If backend is not available but we haven't detected it yet\n      if (err.message.includes('Network Error') || err.response?.status === 500) {\n        setBackendAvailable(false);\n        // Try to find in sample data\n        const order = SAMPLE_ORDERS.find(order => order.userID === parseInt(id));\n        if (order) {\n          toast.warning('Backend server is not available. Using sample data for demonstration purposes.');\n          return order;\n        } else {\n          // Create a fallback order if ID wasn't found\n          const fallbackOrder = {\n            userID: parseInt(id),\n            customerName: \"Guest Customer\",\n            orderDate: new Date().toISOString(),\n            totalPrice: 0,\n            status: \"PREPARING\",\n            items: \"Unknown item\"\n          };\n          toast.info('Order not found. Creating placeholder order for demonstration.');\n          return fallbackOrder;\n        }\n      }\n      \n      setError('Failed to fetch order details');\n      toast.error('Failed to fetch order details');\n      console.error('Error fetching order:', err);\n      \n      // Return a fallback order even when error occurs\n      const fallbackOrder = {\n        userID: parseInt(id),\n        customerName: \"Guest Customer\",\n        orderDate: new Date().toISOString(),\n        totalPrice: 0,\n        status: \"PREPARING\",\n        items: \"Unknown item\"\n      };\n      return fallbackOrder;\n    } finally {\n      setLoading(false);\n    }\n  }, [backendAvailable]);\n\n  // Create a new order\n  const createOrder = useCallback(async (orderData) => {\n    setLoading(true);\n    try {\n      if (!backendAvailable) {\n        // Create a mock order if backend is not available\n        const newOrder = {\n          ...orderData,\n          userID: SAMPLE_ORDERS.length + 1,\n          orderDate: new Date().toISOString(),\n          status: 'PREPARING'\n        };\n        \n        setOrders(prevOrders => [...prevOrders, newOrder]);\n        toast.success('Order created successfully! (Using sample data)');\n        setError(null);\n        return newOrder;\n      }\n      \n      const response = await axios.post('/api/orders', orderData);\n      setOrders(prevOrders => [...prevOrders, response.data]);\n      toast.success('Order created successfully!');\n      setError(null);\n      return response.data;\n    } catch (err) {\n      // If backend is not available but we haven't detected it yet\n      if (err.message.includes('Network Error') || err.response?.status === 500) {\n        setBackendAvailable(false);\n        // Create a mock order\n        const newOrder = {\n          ...orderData,\n          userID: SAMPLE_ORDERS.length + 1,\n          orderDate: new Date().toISOString(),\n          status: 'PREPARING'\n        };\n        \n        setOrders(prevOrders => [...prevOrders, newOrder]);\n        toast.warning('Backend server is not available. Created order with sample data.');\n        return newOrder;\n      }\n      \n      setError('Failed to create order');\n      toast.error('Failed to create order');\n      console.error('Error creating order:', err);\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [backendAvailable]);\n\n  // Update an order\n  const updateOrder = useCallback(async (id, orderData) => {\n    setLoading(true);\n    try {\n      if (!backendAvailable) {\n        // Update order in sample data if backend is not available\n        const updatedOrder = { ...orderData, userID: parseInt(id) };\n        \n        setOrders(prevOrders => \n          prevOrders.map(order => \n            order.userID === parseInt(id) ? updatedOrder : order\n          )\n        );\n        toast.success('Order updated successfully! (Using sample data)');\n        setError(null);\n        return updatedOrder;\n      }\n      \n      const response = await axios.put(`/api/orders/${id}`, orderData);\n      setOrders(prevOrders => \n        prevOrders.map(order => \n          order.userID === parseInt(id) ? response.data : order\n        )\n      );\n      toast.success('Order updated successfully!');\n      setError(null);\n      return response.data;\n    } catch (err) {\n      // If backend is not available but we haven't detected it yet\n      if (err.message.includes('Network Error') || err.response?.status === 500) {\n        setBackendAvailable(false);\n        // Update in sample data\n        const updatedOrder = { ...orderData, userID: parseInt(id) };\n        \n        setOrders(prevOrders => \n          prevOrders.map(order => \n            order.userID === parseInt(id) ? updatedOrder : order\n          )\n        );\n        toast.warning('Backend server is not available. Updated order with sample data.');\n        return updatedOrder;\n      }\n      \n      setError('Failed to update order');\n      toast.error('Failed to update order');\n      console.error('Error updating order:', err);\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [backendAvailable]);\n\n  // Update order status\n  const updateOrderStatus = useCallback(async (id, newStatus) => {\n    setLoading(true);\n    try {\n      if (!backendAvailable) {\n        // Update status in sample data if backend is not available\n        let updatedOrder = null;\n        \n        setOrders(prevOrders => {\n          const newOrders = prevOrders.map(order => {\n            if (order.userID === parseInt(id)) {\n              updatedOrder = { ...order, status: newStatus };\n              return updatedOrder;\n            }\n            return order;\n          });\n          return newOrders;\n        });\n        \n        toast.success(`Order status updated to ${newStatus} (Using sample data)`);\n        setError(null);\n        return updatedOrder;\n      }\n      \n      const response = await axios.patch(`/api/orders/${id}/status`, newStatus);\n      setOrders(prevOrders => \n        prevOrders.map(order => \n          order.userID === parseInt(id) ? response.data : order\n        )\n      );\n      toast.success(`Order status updated to ${newStatus}`);\n      setError(null);\n      return response.data;\n    } catch (err) {\n      // If backend is not available but we haven't detected it yet\n      if (err.message.includes('Network Error') || err.response?.status === 500) {\n        setBackendAvailable(false);\n        // Update in sample data\n        let updatedOrder = null;\n        \n        setOrders(prevOrders => {\n          const newOrders = prevOrders.map(order => {\n            if (order.userID === parseInt(id)) {\n              updatedOrder = { ...order, status: newStatus };\n              return updatedOrder;\n            }\n            return order;\n          });\n          return newOrders;\n        });\n        \n        toast.warning('Backend server is not available. Updated order status with sample data.');\n        return updatedOrder;\n      }\n      \n      setError('Failed to update order status');\n      toast.error('Failed to update order status');\n      console.error('Error updating order status:', err);\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [backendAvailable]);\n\n  // Delete an order\n  const deleteOrder = useCallback(async (id) => {\n    setLoading(true);\n    try {\n      if (!backendAvailable) {\n        // Delete from sample data if backend is not available\n        setOrders(prevOrders => prevOrders.filter(order => order.userID !== parseInt(id)));\n        toast.success('Order deleted successfully! (Using sample data)');\n        setError(null);\n        return true;\n      }\n      \n      await axios.delete(`/api/orders/${id}`);\n      setOrders(prevOrders => prevOrders.filter(order => order.userID !== parseInt(id)));\n      toast.success('Order deleted successfully!');\n      setError(null);\n      return true;\n    } catch (err) {\n      // If backend is not available but we haven't detected it yet\n      if (err.message.includes('Network Error') || err.response?.status === 500) {\n        setBackendAvailable(false);\n        // Delete from sample data\n        setOrders(prevOrders => prevOrders.filter(order => order.userID !== parseInt(id)));\n        toast.warning('Backend server is not available. Deleted order from sample data.');\n        return true;\n      }\n      \n      setError('Failed to delete order');\n      toast.error('Failed to delete order');\n      console.error('Error deleting order:', err);\n      return false;\n    } finally {\n      setLoading(false);\n    }\n  }, [backendAvailable]);\n\n  // Load orders on initial mount\n  useEffect(() => {\n    fetchOrders();\n  }, [fetchOrders]);\n\n  const contextValue = {\n    orders,\n    loading,\n    error,\n    backendAvailable,\n    fetchOrders,\n    fetchOrderById,\n    createOrder,\n    updateOrder,\n    updateOrderStatus,\n    deleteOrder\n  };\n\n  return (\n    <OrderContext.Provider value={contextValue}>\n      {children}\n    </OrderContext.Provider>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}